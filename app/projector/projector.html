<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EpicWorship Projector</title>
    <style>
        body {
            background-color: black;
        }

        #canvas {
            background-color: black;
        }

        .fullscreen {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
    </style>
    <script>
      if(process.env.NODE_ENV === 'production') {
        console.log('SENTRY ACTIVATED')
        const Sentry = require("@sentry/electron");
        Sentry.init({ dsn: "https://8a81eeb019fa4233a8ce3f2835129b4f@sentry.io/1443354" });
      }else{
        console.log('SENTRY DISABLED: Not production environment')
      }
    </script>
    <script src="createjs.min.js"></script>
    <!--<script-->
    <!--src="https://code.jquery.com/jquery-3.3.1.min.js"-->
    <!--crossorigin="anonymous"></script>-->
    <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>-->
    <base href="./" />
</head>
<body onload="startTheParty();">

<!--width and height here determines resolution of canvas as well, regardless of fullscreen styling-->
<canvas id="projectorCanvas" width="1920px" height="1080px" class="fullscreen"></canvas>
<!--<canvas id="projectorCanvas" width="800" height="600px" class="fullscreen"></canvas>-->

<script type="text/javascript">

  const virtualWidth = 1000;
  const virtualHeight = 1000;

  const electron = require("electron").remote;
  const process = electron.getGlobal("process");
  global.APPBASE = process.env.realAppBase;

  function startTheParty() {

    //Register canvas
    var stage = new createjs.Stage("projectorCanvas");
    var bgContainer = new createjs.Container();
    var frontContainer = new createjs.Container();
    stage.addChild(bgContainer);
    stage.addChild(frontContainer);

    const maintainAspectRatioOnResize = false;

    createjs.Ticker.framerate= 60;
    createjs.Ticker.addEventListener("tick", stage);

    function resize() {
      if (maintainAspectRatioOnResize) {
        stage.canvas.width = window.innerWidth;
        stage.canvas.height = window.innerHeight;
      }
      stage.update();
    }

    resize();


    var ipc = require("electron").ipcRenderer;
    ipc.on("toProjector", function(evt, data) {
      console.log("toProjector", data);

      processAction(data);
      setTimeout(()=>{
        console.log('post-Action report', {stageChildren: stage.children});
      }, 2000);

    });

    let previousScene = {
      background: null,
      nodes: [],
      _payload: null
    };
    let activeScene = {
      background: null,
      nodes: [],
      _payload: null
    };

    function processAction(data) {

      if (data.action === "replaceScene") {
        previousScene = activeScene;
        activeScene = {
          background: null,
          nodes: [],
          _payload: data
        };

        //Begin exit transitions for previous scene nodes
        previousScene.nodes.forEach((node) => {
          exitNode(node);
        });
        previousScene.nodes = []; //release references to old nodes so they get garbage colected after tweens

      }

      data.nodes.forEach((nodeDesc) => {
        enterNode(nodeDesc);
      });

      // stage.update();
    }

    function enterNode(nodeDesc) {
      const handler = enterNodeHandlers[nodeDesc.type];
      if (handler) handler(nodeDesc);
    }

    function exitNode(node, speed = 200) {
      //node exit transitions are fairly standard. Just fadeout and remove from stage afterwards.
      createjs.Tween.get(node, speed)
        .to({ alpha: 0 }, speed)
        .call(() => {
          //remove node
          frontContainer.removeChild(node);
        });

    }

    //Resizing the window
    window.addEventListener("resize", resize);

    // ~~~~

    function sx(val) {
      return val / (virtualWidth / stage.canvas.width);
    }

    function sy(val) {
      return val / (virtualHeight / stage.canvas.height);
    }

    let bgOldVideoDOM = null;
    let bgVideoDOM = null;

    // let activeBg = null;

    function destroyVideoDOM(dom){
      if(dom && dom.parentNode){
        dom.pause();
        dom.parentNode.removeChild(dom);
        dom = null;
      }
    }

    const enterNodeHandlers = {
      staticBackground: (nodeDesc) => {

        var image = new Image();
        image.src = nodeDesc.src;
        image.onload = (evt) => {
          var bg = new createjs.Bitmap(evt.target);
          bg.x = 0;
          bg.y = 0;
          bg.scaleX = stage.canvas.width / image.width;
          bg.scaleY = stage.canvas.height / image.height;
          bg.alpha = 0;

          bgContainer.addChild(bg);



          createjs.Tween.get(bg)
            .to({ alpha: 1 }, 500) // fade in speed 0.5s
            .call(() => {

              // debugger;
              if(activeScene.background) {
                console.log('Static BG transitioned in. Removing previous bg');
                bgContainer.removeChild(activeScene.background);
              }
              activeScene.background = bg;
              //Clean up any video bg doms
              destroyVideoDOM(bgVideoDOM);
              destroyVideoDOM(bgOldVideoDOM);
            });
        };

      },
      videoBackground: (nodeDesc) => {
        // console.log('video',nodeDesc.src);

        if (bgVideoDOM) {
          bgOldVideoDOM = bgVideoDOM;
        }

        bgVideoDOM = document.createElement("video");
        bgVideoDOM.autoplay = true;
        bgVideoDOM.loop = true;
        // bgVideoDOM.controls = false;
        bgVideoDOM.hidden = true;
        bgVideoDOM.preload = true;
        // bgVideoDOM.width = 100;
        bgVideoDOM.muted = true;
        // bgVideoDOM.volume = 0;
        // bgVideoDOM.setAttribute("webkit-playsinline","true");
        // bgVideoDOM.setAttribute("playsinline","true");
        // bgVideoDOM.setAttribute("muted",true);
        // bgVideoDOM.setAttribute("width",stage.canvas.width);
        // bgVideoDOM.height = 100;
        bgVideoDOM.src = nodeDesc.src;

        document.body.append(bgVideoDOM);

        bgVideoDOM.play();

        bgVideoDOM.oncanplay = (evt) => {
          var vidBuffer = new createjs.VideoBuffer(bgVideoDOM);
          var bg = new createjs.Bitmap(bgVideoDOM);

          bg.x = 0;
          bg.y = 0;
          bg.scaleX = stage.canvas.width / bgVideoDOM.videoWidth;
          bg.scaleY = stage.canvas.height / bgVideoDOM.videoHeight;
          bg.alpha = 0;
          bgContainer.addChild(bg);


          createjs.Tween.get(bg)
            .to({ alpha: 1 }, 500) // fade in speed 0.5s
            .call(() => {

              // debugger;
              if(activeScene.background) {
                console.log('Video BG transitioned in. Removing previous bg');
                bgContainer.removeChild(activeScene.background);
              }
              activeScene.background = bg;

              //Clean up old video bg doms
              destroyVideoDOM(bgOldVideoDOM);
            });
        };

      },
      text: (nodeDesc) => {
        const textContainer = new createjs.Container();
        textContainer.alpha = 0;

        textContainer.x = sx(nodeDesc.bounds.x) - 20;
        textContainer.y = sy(nodeDesc.bounds.y);

        var text = new createjs.Text(nodeDesc.text, `${nodeDesc.fontSize}px ${nodeDesc.font}`, nodeDesc.color);
        text.textAlign = nodeDesc.textAlign;
        text.lineWidth = sx(nodeDesc.bounds.width);

        textContainer.addChild(text);
        frontContainer.addChild(textContainer);
        activeScene.nodes.push(textContainer);

        let destinationX = sx(nodeDesc.bounds.x);

        //Having rendered the text, Make adjustments
        let realBounds = text.getBounds();

        //center text align requires X-compensation
        if (nodeDesc.textAlign === "center") {
          const offset = realBounds.width / 2;
          console.log({ offset });
          textContainer.x += offset;
          destinationX += offset;
        }

        //Fit text in bounds
        const maxHeight = sy(nodeDesc.bounds.height);
        if (realBounds.height > maxHeight) {
          console.log({ maxHeight, realHeight: realBounds.height });
          //NOTE: As determined in EpicWorship v1, a looping font reduction yields a far more superior result
          // than mere scaling. Putting scaling method as comment for anyone who wants to verify this.
          /*
          const fontCompScaleFactor = 1+((maxHeight - realBounds.height)/realBounds.height);
          console.log({fontCompScaleFactor})
          text.scaleX = fontCompScaleFactor;
          text.scaleY = fontCompScaleFactor;
          */

          //Do Intelligent font size reduction
          let fontSize = nodeDesc.fontSize;
          while (realBounds.height > maxHeight) {
            fontSize -= 5; //decrement step of font size by 5.
            text.font = `${fontSize}px ${nodeDesc.font}`;
            realBounds = text.getBounds();
          }
        }

        //deepen shadow
        if (nodeDesc.shadow > 0) {
          text.shadow = new createjs.Shadow(nodeDesc.shadowColor || "#000000", 0, 0, 20);

          //for any extra depth, clone text and give shadow
          for (var v = 1; v < nodeDesc.shadow ; v++) {
            var stext = text.clone(true);
            stext.shadow = new createjs.Shadow(nodeDesc.shadowColor || "#000000", Math.random() * 5, Math.random() * 5, 40);
            textContainer.addChild(stext);
          }
        }

        //Adjustments complete. Now render
        createjs.Tween.get(textContainer)
          .to({ alpha: 1, x: destinationX }, 300) // fade in speed 0.5s
          .call(() => {

          });

      }
    };


  }
</script>
</body>
</html>