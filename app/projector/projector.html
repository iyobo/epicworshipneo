<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EpicWorship Projector</title>
    <style>
        body {
            /*background-color: black;*/
        }

        #canvas {
            /*background-color: black;*/
        }

        .fullscreen {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
    </style>
    <script src="createjs.min.js"></script>
    <!--<script-->
    <!--src="https://code.jquery.com/jquery-3.3.1.min.js"-->
    <!--crossorigin="anonymous"></script>-->
    <!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>-->
</head>
<body onload="startTheParty();">

<!--width and height here determines resolution of canvas as well, regardless of fullscreen styling-->
<canvas id="projectorCanvas" width="1920px" height="1080px" class="fullscreen"></canvas>

<div id="mediaDOMs">
    <video id="bgvid1" class="fullscreen" autoplay loop></video>
    <video id="bgvid2" class="fullscreen" autoplay loop></video>
</div>
<script type="text/javascript" src="src/projector.js"></script>
<script type="text/javascript">

  const virtualWidth = 1000;
  const virtualHeight = 1000;

  function startTheParty() {

    //Register canvas
    var stage = new createjs.Stage("projectorCanvas");
    var bgContainer = new createjs.Container();
    var frontContainer = new createjs.Container();
    stage.addChild(bgContainer);
    stage.addChild(frontContainer);

    const maintainAspectRatioOnResize = false;

    createjs.Ticker.setFPS(60);
    createjs.Ticker.addEventListener("tick", stage);

    function resize() {
      if (maintainAspectRatioOnResize) {
        stage.canvas.width = window.innerWidth;
        stage.canvas.height = window.innerHeight;
      }
      stage.update();
    }

    resize();


    var ipc = require("electron").ipcRenderer;
    ipc.on("toProjector", function(evt, data) {
      console.log("toProjector", data);

      processAction(data);

    });

    let previousScene = {
      background: null,
      nodes: [],
      _payload: null
    };
    let activeScene = {
      background: null,
      nodes: [],
      _payload: null
    };

    function processAction(data) {

      switch (data.action) {
        case "scene": {
          //make current active scene previous scene
          previousScene = activeScene;
          activeScene = {
            background: null,
            nodes: [],
            _payload: data
          };

          //Begin exit transitions for previous scene nodes
          previousScene.nodes.forEach((node) => {
            exitNode(node);
          });
          previousScene.nodes = []; //release references to old nodes so they get garbage colected after tweens

          //Begin entry transitions for new scene node
          data.nodes.forEach((nodeDesc) => {
            enterNode(nodeDesc);
          });
        }
      }
      // stage.update();
    }

    function enterNode(nodeDesc) {
      const handler = enterNodeHandlers[nodeDesc.type];
      if (handler) handler(nodeDesc);
    }

    function exitNode(node, speed = 200) {
      //node exit transitions are fairly standard. Just fadeout and remove from stage afterwards.
      createjs.Tween.get(node, speed)
        .to({ alpha: 0 }, speed)
        .call(() => {
          //remove node
        });

    }

    //Resizing the window
    window.addEventListener("resize", resize);

    // ~~~~

    function sx(val) {
      return val / (virtualWidth / stage.canvas.width);
    }

    function sy(val) {
      return val / (virtualHeight / stage.canvas.height);
    }

    const enterNodeHandlers = {
      staticBackground: (nodeDesc) => {

        var image = new Image();
        image.src = nodeDesc.src;
        image.onload = (evt) => {
          var bg = new createjs.Bitmap(evt.target);
          bg.x = 0;
          bg.y = 0;
          bg.scaleX = stage.canvas.width / image.width;
          bg.scaleY = stage.canvas.height / image.height;
          bg.alpha = 0;

          // stage.addChild(bg);
          // stage.setChildIndex(bg, 0);
          bgContainer.addChild(bg);

          activeScene.background = bg;

          createjs.Tween.get(bg)
            .to({ alpha: 1 }, 500) // fade in speed 0.5s
            .call(() => {

            });
          // stage.update();
        };

      },
      text: (nodeDesc) => {
        var text = new createjs.Text(nodeDesc.text, `${nodeDesc.fontSize}px ${nodeDesc.font}`, nodeDesc.color);

        text.x = sx(nodeDesc.bounds.x - 25);
        text.y = sy(nodeDesc.bounds.y);
        text.alpha = 0;
        text.textAlign = nodeDesc.textAlign;
        text.lineWidth = sx(nodeDesc.bounds.width);
        text.shadow = new createjs.Shadow(nodeDesc.shadowColor || "#000000", 5, 5, 10);

        frontContainer.addChild(text);
        activeScene.nodes.push(text);

        let destinationX = sx(nodeDesc.bounds.x);

        //Having rendered the text, Make adjustments
        let realBounds = text.getBounds();

        //center text align requires X-compensation
        if (nodeDesc.textAlign === "center") {
          const offset = realBounds.width / 2;
          console.log({ offset });
          text.x += offset;
          destinationX += offset;
        }

        //Fit text in bounds
        const maxHeight = sy(nodeDesc.bounds.height);
        if (realBounds.height > maxHeight) {
          console.log({ maxHeight, realHeight: realBounds.height });
          //NOTE: As determined in EpicWorship v1, a looping font reduction yields a far more superior result
          // than mere scaling. Putting scaling method as comment for anyone who wants to verify this.
          /*
          const fontCompScaleFactor = 1+((maxHeight - realBounds.height)/realBounds.height);
          console.log({fontCompScaleFactor})
          text.scaleX = fontCompScaleFactor;
          text.scaleY = fontCompScaleFactor;
          */

          //Do Intelligent font size reduction
          let fontSize = nodeDesc.fontSize;
          while (realBounds.height > maxHeight) {
            fontSize -= 5; //decrement step of font size by 5.
            text.font = `${fontSize}px ${nodeDesc.font}`;
            realBounds = text.getBounds();
          }
        }


        //Adjustments complete. Now render
        createjs.Tween.get(text)
          .to({ alpha: 1, x: destinationX }, 300) // fade in speed 0.5s
          .call(() => {

          });

        // console.log("sx", sx(1), "sy", sy(1), "text bounds:", text.getBounds());
      }
    };


  }
</script>
</body>
</html>